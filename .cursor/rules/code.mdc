---
description: 
globs: 
alwaysApply: true
---
# Flutter Code Quality Rules

This document outlines the coding standards and best practices to follow in this Flutter project to ensure code quality, maintainability, and consistency. These rules are intended to be used by developers and can also be referenced by Language Model (LLM) tools for code analysis and suggestions.

## I. Code Style and Formatting

1.  **Use Dart's Official Style Guide:** Adhere to the conventions and recommendations outlined in the official Dart style guide. [https://dart.dev/guides/language/effective-dart](https://dart.dev/guides/language/effective-dart)
2.  **Consistent Formatting:** Use the `flutter format` command to automatically format your code. Configure your IDE to format code on save.
3.  **Line Length:** Keep lines of code within a reasonable length (e.g., 80-120 characters) to improve readability.
4.  **Indentation:** Use 2 spaces for indentation. Avoid tabs.
5.  **Comments:** Write clear and concise comments to explain complex logic, the purpose of functions, and important decisions. Use doc comments (`///`) for public APIs.
6.  **Avoid Magic Numbers:** Define constants for literal values used in the code to improve readability and maintainability.
7.  **Imports:** Organize imports according to the following order:
    *   Dart SDK imports
    *   Flutter framework imports
    *   Third-party package imports
    *   Project-local imports
8.  **Avoid Unnecessary Code:** Remove commented-out code, unused variables, and unnecessary imports.

## II. Naming Conventions

1.  **PascalCase for Classes and Enums:** Use PascalCase (e.g., `MyClass`, `OrderStatus`) for class and enum names.
2.  **camelCase for Variables, Functions, and Parameters:** Use camelCase (e.g., `myVariable`, `calculateTotal`, `userName`) for variables, functions, and parameters.
3.  **snake_case for Library and File Names:** Use snake_case (e.g., `my_library.dart`, `user_model.dart`) for library and file names.
4.  **UPPER_CASE_WITH_UNDERSCORES for Constants:** Use UPPER_CASE_WITH_UNDERSCORES (e.g., `MAX_USERS`, `DEFAULT_TIMEOUT`) for constants.
5.  **Meaningful Names:** Choose descriptive and meaningful names that clearly indicate the purpose of the entity.

## III. State Management

1.  **Choose an Appropriate State Management Solution:** Select a state management solution (e.g., Provider, Riverpod, BLoC/Cubit, GetX) that fits the complexity of the feature or application.
2.  **Separate UI and Business Logic:** Keep UI widgets separate from business logic to improve testability and maintainability.
3.  **Immutable State:** Prefer immutable state objects to make state changes predictable and easier to reason about.
4.  **AvoidsetState for Complex Logic:** For complex state updates, use the chosen state management solution instead of directly calling `setState` in widgets.
5.  **Proper Disposal of Resources:** Ensure that resources like `StreamSubscription`s and `AnimationController`s are properly disposed of in the `dispose` method of stateful widgets or within the state management solution.

## IV. Widget Usage

1.  **Build Small, Reusable Widgets:** Break down complex UIs into smaller, reusable widgets to improve code organization and maintainability.
2.  **Use `const` Where Possible:** Use the `const` keyword for widgets that don't need to rebuild to improve performance.
3.  **Key Usage:** Use `Key`s appropriately, especially when working with lists of widgets or during widget refactoring.
4.  **Avoid Deeply Nested Widgets:** Try to avoid excessively deep widget trees as they can impact performance and readability. Consider using techniques like extracting widgets or using layout widgets effectively.

## V. Error Handling

1.  **Use `try-catch` Blocks:** Implement `try-catch` blocks to handle potential exceptions and prevent application crashes.
2.  **Provide Meaningful Error Messages:** Display user-friendly error messages to guide users when errors occur.
3.  **Logging:** Implement proper logging to track errors and debug issues effectively.
4.  **Handle API Errors Gracefully:** When integrating with APIs, handle different error codes and responses appropriately.

## VI. Performance

1.  **Lazy Loading:** Implement lazy loading for resources and widgets that are not immediately visible.
2.  **Optimize Image Loading:** Use appropriate image formats, compress images, and consider using caching mechanisms.
3.  **Avoid Expensive Operations in `build` Method:** The `build` method should be lightweight. Avoid performing expensive computations or I/O operations directly within it.
4.  **Use `shouldRepaint` in `CustomPainter`:** Implement the `shouldRepaint` method in `CustomPainter` to optimize custom drawing.
5.  **Profile Your Application:** Use Flutter DevTools to profile your application and identify performance bottlenecks.

## VII. Testing

1.  **Write Unit Tests:** Write unit tests to verify the logic of individual functions and classes.
2.  **Write Widget Tests:** Write widget tests to ensure that UI components render correctly and behave as expected.
3.  **Write Integration Tests:** Write integration tests to test the interaction between different parts of the application.
4.  **Aim for Good Test Coverage:** Strive for a reasonable level of test coverage to ensure the reliability of the codebase.

## VIII. Google Gemini API Integration

1.  **Secure API Key Management:** Store and handle Google Gemini API keys securely. Avoid hardcoding them directly in the code. Consider using environment variables or secure storage mechanisms.
2.  **Asynchronous Operations:** Perform API calls asynchronously to avoid blocking the main UI thread.
3.  **Prompt Engineering:** Follow best practices for prompt engineering to get the desired results from the Gemini API.
4.  **Error Handling for API Calls:** Implement specific error handling for Gemini API calls to manage potential issues like network errors or API-specific errors.

## IX. Ollama Integration (Future)

1.  **Modular Design:** Ensure the architecture is modular to easily integrate Ollama in the future.
2.  **Abstract AI Model Interactions:** Design interfaces or abstract classes to handle interactions with different AI models (Gemini and potentially Ollama) in a consistent way.

## X. Google Drive Integration

1.  **Use Appropriate Packages:** Utilize well-maintained packages like `googleapis` and `google_sign_in` for Google Drive integration.
2.  **Handle Authentication:** Implement the OAuth 2.0 flow correctly for user authentication with Google Drive.
3.  **Asynchronous Operations:** Perform Google Drive operations asynchronously.
4.  **Error Handling:** Handle potential errors during file operations (upload, download, sync).


By following these rules and guidelines, we can maintain a high standard of code quality in our Flutter project, making it easier to develop, maintain, and scale the application over time.